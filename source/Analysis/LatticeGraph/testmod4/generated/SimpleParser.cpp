/** \file
 *  This C source file was generated by $ANTLR version 3.2 Sep 23, 2009 12:02:23
 *
 *     -  From the grammar source file : C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g
 *     -                            On : 2010-10-11 13:03:22
 *     -                for the parser : SimpleParserParser *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "SimpleParser.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pSimpleParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pSimpleParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pSimpleParser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pSimpleParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */
 
#undef	    PARSER		    
#undef	    RECOGNIZER		    
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO		    
#undef		DBG

#define	    PARSER							ctx->pParser  
#define	    RECOGNIZER						PARSER->rec
#define		PSRSTATE						RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)				RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define		MEMOIZE(ri,si)					RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT							PARSER->tstream
#define	    STRSTREAM						INPUT
#define		ISTREAM							INPUT->istream
#define		INDEX()							ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()					(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION						PSRSTATE->exception
#define	    MATCHT(t, fs)					RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()						RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK					    PSRSTATE->following
#define	    FOLLOWPUSH(x)					FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()						FOLLOWSTACK->pop(FOLLOWSTACK)
#define	    PRECOVER()						RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()					RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)							INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)							INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()					RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()						ISTREAM->consume(ISTREAM)
#define	    MARK()							ISTREAM->mark(ISTREAM)
#define	    REWIND(m)						ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()					ISTREAM->rewindLast(ISTREAM)
#define		SEEK(n)							ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY					PSRSTATE->errorRecovery
#define	    FAILEDFLAG						PSRSTATE->failed
#define	    HASFAILED()						(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING					PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger

#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a SimpleParser_complex_cond scope set 
 */
static pSimpleParser_complex_cond_SCOPE   pSimpleParser_complex_condPush(pSimpleParser ctx);
static void ANTLR3_CDECL complex_condFree(pSimpleParser_complex_cond_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL complex_condFree(pSimpleParser_complex_cond_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a SimpleParser complex_cond scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pSimpleParser_complex_condTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pSimpleParser_complex_cond_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pSimpleParser_complex_cond_SCOPE
pSimpleParser_complex_condPush(pSimpleParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pSimpleParser_complex_cond_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pSimpleParser_complex_condStack->size(ctx->pSimpleParser_complex_condStack) > ctx->pSimpleParser_complex_condStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pSimpleParser_complex_cond_SCOPE)ctx->pSimpleParser_complex_condStack->get(ctx->pSimpleParser_complex_condStack, ctx->pSimpleParser_complex_condStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pSimpleParser_complex_cond_SCOPE) ANTLR3_MALLOC(sizeof(SimpleParser_complex_cond_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pSimpleParser_complex_condStack->push(ctx->pSimpleParser_complex_condStack, newAttributes, (void (*)(void *))complex_condFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pSimpleParser_complex_condStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a SimpleParser_solution scope set 
 */
static pSimpleParser_solution_SCOPE   pSimpleParser_solutionPush(pSimpleParser ctx);
static void ANTLR3_CDECL solutionFree(pSimpleParser_solution_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL solutionFree(pSimpleParser_solution_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a SimpleParser solution scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pSimpleParser_solutionTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pSimpleParser_solution_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pSimpleParser_solution_SCOPE
pSimpleParser_solutionPush(pSimpleParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pSimpleParser_solution_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pSimpleParser_solutionStack->size(ctx->pSimpleParser_solutionStack) > ctx->pSimpleParser_solutionStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pSimpleParser_solution_SCOPE)ctx->pSimpleParser_solutionStack->get(ctx->pSimpleParser_solutionStack, ctx->pSimpleParser_solutionStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pSimpleParser_solution_SCOPE) ANTLR3_MALLOC(sizeof(SimpleParser_solution_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pSimpleParser_solutionStack->push(ctx->pSimpleParser_solutionStack, newAttributes, (void (*)(void *))solutionFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pSimpleParser_solutionStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a SimpleParser_expr scope set 
 */
static pSimpleParser_expr_SCOPE   pSimpleParser_exprPush(pSimpleParser ctx);
static void ANTLR3_CDECL exprFree(pSimpleParser_expr_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL exprFree(pSimpleParser_expr_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a SimpleParser expr scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pSimpleParser_exprTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pSimpleParser_expr_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pSimpleParser_expr_SCOPE
pSimpleParser_exprPush(pSimpleParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pSimpleParser_expr_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pSimpleParser_exprStack->size(ctx->pSimpleParser_exprStack) > ctx->pSimpleParser_exprStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pSimpleParser_expr_SCOPE)ctx->pSimpleParser_exprStack->get(ctx->pSimpleParser_exprStack, ctx->pSimpleParser_exprStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pSimpleParser_expr_SCOPE) ANTLR3_MALLOC(sizeof(SimpleParser_expr_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pSimpleParser_exprStack->push(ctx->pSimpleParser_exprStack, newAttributes, (void (*)(void *))exprFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pSimpleParser_exprStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a SimpleParser_term scope set 
 */
static pSimpleParser_term_SCOPE   pSimpleParser_termPush(pSimpleParser ctx);
static void ANTLR3_CDECL termFree(pSimpleParser_term_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL termFree(pSimpleParser_term_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a SimpleParser term scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pSimpleParser_termTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pSimpleParser_term_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pSimpleParser_term_SCOPE
pSimpleParser_termPush(pSimpleParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pSimpleParser_term_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pSimpleParser_termStack->size(ctx->pSimpleParser_termStack) > ctx->pSimpleParser_termStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pSimpleParser_term_SCOPE)ctx->pSimpleParser_termStack->get(ctx->pSimpleParser_termStack, ctx->pSimpleParser_termStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pSimpleParser_term_SCOPE) ANTLR3_MALLOC(sizeof(SimpleParser_term_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pSimpleParser_termStack->push(ctx->pSimpleParser_termStack, newAttributes, (void (*)(void *))termFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pSimpleParser_termStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}




/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */



/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   SimpleParserTokenNames[17+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>", 
        (pANTLR3_UINT8) "<UP>", 
        (pANTLR3_UINT8) "T_NEWLINE",
        (pANTLR3_UINT8) "WS",
        (pANTLR3_UINT8) "Digit",
        (pANTLR3_UINT8) "T_DIGIT_STRING",
        (pANTLR3_UINT8) "T_VEC_beg",
        (pANTLR3_UINT8) "T_VEC_end",
        (pANTLR3_UINT8) "T_OPEN_BR",
        (pANTLR3_UINT8) "T_CLOSE_BR",
        (pANTLR3_UINT8) "T_NEWPARAM",
        (pANTLR3_UINT8) "T_DIV",
        (pANTLR3_UINT8) "T_NIL",
        (pANTLR3_UINT8) "T_IF",
        (pANTLR3_UINT8) "T_NOT",
        (pANTLR3_UINT8) "T_AND",
        (pANTLR3_UINT8) "T_OR",
        (pANTLR3_UINT8) "T_LIST",
        (pANTLR3_UINT8) "T_EOF"
       };

        
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pSimpleParser_complex_condStack
 */
void
pSimpleParser_complex_condPop(pSimpleParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(complex_cond)->free != NULL)
	{
        SCOPE_TOP(complex_cond)->free(SCOPE_TOP(complex_cond));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pSimpleParser_complex_condStack_limit--;
    SCOPE_TOP(complex_cond) = (pSimpleParser_complex_cond_SCOPE)(ctx->pSimpleParser_complex_condStack->get(ctx->pSimpleParser_complex_condStack, ctx->pSimpleParser_complex_condStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pSimpleParser_solutionStack
 */
void
pSimpleParser_solutionPop(pSimpleParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(solution)->free != NULL)
	{
        SCOPE_TOP(solution)->free(SCOPE_TOP(solution));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pSimpleParser_solutionStack_limit--;
    SCOPE_TOP(solution) = (pSimpleParser_solution_SCOPE)(ctx->pSimpleParser_solutionStack->get(ctx->pSimpleParser_solutionStack, ctx->pSimpleParser_solutionStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pSimpleParser_exprStack
 */
void
pSimpleParser_exprPop(pSimpleParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(expr)->free != NULL)
	{
        SCOPE_TOP(expr)->free(SCOPE_TOP(expr));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pSimpleParser_exprStack_limit--;
    SCOPE_TOP(expr) = (pSimpleParser_expr_SCOPE)(ctx->pSimpleParser_exprStack->get(ctx->pSimpleParser_exprStack, ctx->pSimpleParser_exprStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pSimpleParser_termStack
 */
void
pSimpleParser_termPop(pSimpleParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(term)->free != NULL)
	{
        SCOPE_TOP(term)->free(SCOPE_TOP(term));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pSimpleParser_termStack_limit--;
    SCOPE_TOP(term) = (pSimpleParser_term_SCOPE)(ctx->pSimpleParser_termStack->get(ctx->pSimpleParser_termStack, ctx->pSimpleParser_termStack_limit - 1));
}


// Forward declare the locally static matching functions we have generated.
//
static ComplexCondition*	complex_cond    (pSimpleParser ctx);
static ExtendedQuast*	solution    (pSimpleParser ctx);
static std::list <std::list <int>* >*	all_vectors    (pSimpleParser ctx);
static std::list <int>*	digits_line    (pSimpleParser ctx);
static std::list<int> *	vector    (pSimpleParser ctx);
static int*	one_digit_string    (pSimpleParser ctx);
static void	end_of_lines    (pSimpleParser ctx);
static void	quast_group    (pSimpleParser ctx, ExtendedQuast* cur);
static void	quast    (pSimpleParser ctx, ExtendedQuast* cur);
static void	form    (pSimpleParser ctx, ExtendedQuast* cur);
static NewParamVector*	newparm_group    (pSimpleParser ctx);
static NewParamEquation*	newparmvector    (pSimpleParser ctx);
static ComplexCondition*	expr    (pSimpleParser ctx, ComplexCondition* cur);
static ComplexCondition*	factor    (pSimpleParser ctx, ComplexCondition* cur);
static ComplexCondition*	nest_factor    (pSimpleParser ctx, ComplexCondition* cur);
static ComplexCondition*	term    (pSimpleParser ctx, ComplexCondition* cur);
static ANTLR3_BOOLEAN	synpred1_Simple    (pSimpleParser ctx);
static ANTLR3_BOOLEAN	synpred2_Simple    (pSimpleParser ctx);
static void	SimpleParserFree(pSimpleParser ctx);
/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed. 
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new SimpleParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pSimpleParser
SimpleParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return SimpleParserNewSSD(instream, NULL);
}

/** \brief Create a new SimpleParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pSimpleParser
SimpleParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pSimpleParser ctx;	    /* Context structure we will build and return   */
    
    ctx	= (pSimpleParser) ANTLR3_CALLOC(1, sizeof(SimpleParser));
    
    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }
    
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in SimpleParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our SimpleParser interface
     */
    ctx->complex_cond	= complex_cond;
    ctx->solution	= solution;
    ctx->all_vectors	= all_vectors;
    ctx->digits_line	= digits_line;
    ctx->vector	= vector;
    ctx->one_digit_string	= one_digit_string;
    ctx->end_of_lines	= end_of_lines;
    ctx->quast_group	= quast_group;
    ctx->quast	= quast;
    ctx->form	= form;
    ctx->newparm_group	= newparm_group;
    ctx->newparmvector	= newparmvector;
    ctx->expr	= expr;
    ctx->factor	= factor;
    ctx->nest_factor	= nest_factor;
    ctx->term	= term;
    ctx->synpred1_Simple	= synpred1_Simple;
    ctx->synpred2_Simple	= synpred2_Simple;
    ctx->free			= SimpleParserFree;
    ctx->getGrammarFileName	= getGrammarFileName;
    
    /* Install the scope pushing methods.
     */
    /* ruleAttributeScope(scope)
     */
    ctx->pSimpleParser_complex_condPush     = pSimpleParser_complex_condPush;
    ctx->pSimpleParser_complex_condStack    = antlr3StackNew(0);
    ctx->pSimpleParser_complex_condStack_limit    = 0;
    ctx->pSimpleParser_complex_condTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pSimpleParser_solutionPush     = pSimpleParser_solutionPush;
    ctx->pSimpleParser_solutionStack    = antlr3StackNew(0);
    ctx->pSimpleParser_solutionStack_limit    = 0;
    ctx->pSimpleParser_solutionTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pSimpleParser_exprPush     = pSimpleParser_exprPush;
    ctx->pSimpleParser_exprStack    = antlr3StackNew(0);
    ctx->pSimpleParser_exprStack_limit    = 0;
    ctx->pSimpleParser_exprTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pSimpleParser_termPush     = pSimpleParser_termPush;
    ctx->pSimpleParser_termStack    = antlr3StackNew(0);
    ctx->pSimpleParser_termStack_limit    = 0;
    ctx->pSimpleParser_termTop      = NULL;


        
    

	
    /* Install the token table
     */
    PSRSTATE->tokenNames   = SimpleParserTokenNames;
    
    
    /* Return the newly built parser to the caller
     */
    return  ctx;
}

/** Free the parser resources
 */
 static void
 SimpleParserFree(pSimpleParser ctx)
 {
    /* Free any scope memory
     */
    /* ruleAttributeScope(scope)
     */
    ctx->pSimpleParser_complex_condStack->free(ctx->pSimpleParser_complex_condStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pSimpleParser_solutionStack->free(ctx->pSimpleParser_solutionStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pSimpleParser_exprStack->free(ctx->pSimpleParser_exprStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pSimpleParser_termStack->free(ctx->pSimpleParser_termStack);

    
        
	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);
    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }
 
/** Return token names used by this parser
 *
 * The returned pointer is used as an index into the token names table (using the token 
 * number as the index).
 * 
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames() 
{
        return SimpleParserTokenNames; 
}


    #define getTokenInteger(token)  (atoi((char*)token->getText(token)->chars))
    //typedef list<ComplexCondition*> nodelist;

    
/* Declare the bitsets
 */

/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_complex_cond80  */
static	ANTLR3_BITWORD FOLLOW_expr_in_complex_cond80_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_complex_cond80	= { FOLLOW_expr_in_complex_cond80_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_quast_group_in_solution109  */
static	ANTLR3_BITWORD FOLLOW_quast_group_in_solution109_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_quast_group_in_solution109	= { FOLLOW_quast_group_in_solution109_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_vector_in_all_vectors144  */
static	ANTLR3_BITWORD FOLLOW_vector_in_all_vectors144_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_vector_in_all_vectors144	= { FOLLOW_vector_in_all_vectors144_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_one_digit_string_in_digits_line175  */
static	ANTLR3_BITWORD FOLLOW_one_digit_string_in_digits_line175_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000082) };
static  ANTLR3_BITSET_LIST FOLLOW_one_digit_string_in_digits_line175	= { FOLLOW_one_digit_string_in_digits_line175_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_VEC_beg_in_vector194  */
static	ANTLR3_BITWORD FOLLOW_T_VEC_beg_in_vector194_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_T_VEC_beg_in_vector194	= { FOLLOW_T_VEC_beg_in_vector194_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_digits_line_in_vector196  */
static	ANTLR3_BITWORD FOLLOW_digits_line_in_vector196_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_digits_line_in_vector196	= { FOLLOW_digits_line_in_vector196_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_VEC_end_in_vector198  */
static	ANTLR3_BITWORD FOLLOW_T_VEC_end_in_vector198_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_T_VEC_end_in_vector198	= { FOLLOW_T_VEC_end_in_vector198_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_DIGIT_STRING_in_one_digit_string226  */
static	ANTLR3_BITWORD FOLLOW_T_DIGIT_STRING_in_one_digit_string226_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_T_DIGIT_STRING_in_one_digit_string226	= { FOLLOW_T_DIGIT_STRING_in_one_digit_string226_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_EOF_in_end_of_lines242  */
static	ANTLR3_BITWORD FOLLOW_T_EOF_in_end_of_lines242_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_T_EOF_in_end_of_lines242	= { FOLLOW_T_EOF_in_end_of_lines242_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_quast_in_quast_group297  */
static	ANTLR3_BITWORD FOLLOW_quast_in_quast_group297_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_quast_in_quast_group297	= { FOLLOW_quast_in_quast_group297_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_newparm_group_in_quast_group312  */
static	ANTLR3_BITWORD FOLLOW_newparm_group_in_quast_group312_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_newparm_group_in_quast_group312	= { FOLLOW_newparm_group_in_quast_group312_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_quast_in_quast_group330  */
static	ANTLR3_BITWORD FOLLOW_quast_in_quast_group330_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_quast_in_quast_group330	= { FOLLOW_quast_in_quast_group330_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_form_in_quast365  */
static	ANTLR3_BITWORD FOLLOW_form_in_quast365_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_form_in_quast365	= { FOLLOW_form_in_quast365_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_OPEN_BR_in_quast380  */
static	ANTLR3_BITWORD FOLLOW_T_OPEN_BR_in_quast380_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_T_OPEN_BR_in_quast380	= { FOLLOW_T_OPEN_BR_in_quast380_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_IF_in_quast382  */
static	ANTLR3_BITWORD FOLLOW_T_IF_in_quast382_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010500) };
static  ANTLR3_BITSET_LIST FOLLOW_T_IF_in_quast382	= { FOLLOW_T_IF_in_quast382_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_complex_cond_in_quast386  */
static	ANTLR3_BITWORD FOLLOW_complex_cond_in_quast386_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_complex_cond_in_quast386	= { FOLLOW_complex_cond_in_quast386_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_quast_group_in_quast397  */
static	ANTLR3_BITWORD FOLLOW_quast_group_in_quast397_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_quast_group_in_quast397	= { FOLLOW_quast_group_in_quast397_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_quast_group_in_quast400  */
static	ANTLR3_BITWORD FOLLOW_quast_group_in_quast400_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_quast_group_in_quast400	= { FOLLOW_quast_group_in_quast400_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_CLOSE_BR_in_quast403  */
static	ANTLR3_BITWORD FOLLOW_T_CLOSE_BR_in_quast403_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_T_CLOSE_BR_in_quast403	= { FOLLOW_T_CLOSE_BR_in_quast403_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_OPEN_BR_in_form431  */
static	ANTLR3_BITWORD FOLLOW_T_OPEN_BR_in_form431_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_T_OPEN_BR_in_form431	= { FOLLOW_T_OPEN_BR_in_form431_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_LIST_in_form433  */
static	ANTLR3_BITWORD FOLLOW_T_LIST_in_form433_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000900) };
static  ANTLR3_BITSET_LIST FOLLOW_T_LIST_in_form433	= { FOLLOW_T_LIST_in_form433_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_vector_in_form448  */
static	ANTLR3_BITWORD FOLLOW_vector_in_form448_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000900) };
static  ANTLR3_BITSET_LIST FOLLOW_vector_in_form448	= { FOLLOW_vector_in_form448_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_CLOSE_BR_in_form465  */
static	ANTLR3_BITWORD FOLLOW_T_CLOSE_BR_in_form465_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_T_CLOSE_BR_in_form465	= { FOLLOW_T_CLOSE_BR_in_form465_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_OPEN_BR_in_form485  */
static	ANTLR3_BITWORD FOLLOW_T_OPEN_BR_in_form485_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_T_OPEN_BR_in_form485	= { FOLLOW_T_OPEN_BR_in_form485_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_CLOSE_BR_in_form487  */
static	ANTLR3_BITWORD FOLLOW_T_CLOSE_BR_in_form487_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_T_CLOSE_BR_in_form487	= { FOLLOW_T_CLOSE_BR_in_form487_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_newparmvector_in_newparm_group528  */
static	ANTLR3_BITWORD FOLLOW_newparmvector_in_newparm_group528_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000402) };
static  ANTLR3_BITSET_LIST FOLLOW_newparmvector_in_newparm_group528	= { FOLLOW_newparmvector_in_newparm_group528_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_OPEN_BR_in_newparmvector576  */
static	ANTLR3_BITWORD FOLLOW_T_OPEN_BR_in_newparmvector576_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_T_OPEN_BR_in_newparmvector576	= { FOLLOW_T_OPEN_BR_in_newparmvector576_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_NEWPARAM_in_newparmvector578  */
static	ANTLR3_BITWORD FOLLOW_T_NEWPARAM_in_newparmvector578_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000480) };
static  ANTLR3_BITSET_LIST FOLLOW_T_NEWPARAM_in_newparmvector578	= { FOLLOW_T_NEWPARAM_in_newparmvector578_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_one_digit_string_in_newparmvector580  */
static	ANTLR3_BITWORD FOLLOW_one_digit_string_in_newparmvector580_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_one_digit_string_in_newparmvector580	= { FOLLOW_one_digit_string_in_newparmvector580_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_OPEN_BR_in_newparmvector583  */
static	ANTLR3_BITWORD FOLLOW_T_OPEN_BR_in_newparmvector583_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_T_OPEN_BR_in_newparmvector583	= { FOLLOW_T_OPEN_BR_in_newparmvector583_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_DIV_in_newparmvector585  */
static	ANTLR3_BITWORD FOLLOW_T_DIV_in_newparmvector585_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000980) };
static  ANTLR3_BITSET_LIST FOLLOW_T_DIV_in_newparmvector585	= { FOLLOW_T_DIV_in_newparmvector585_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_vector_in_newparmvector597  */
static	ANTLR3_BITWORD FOLLOW_vector_in_newparmvector597_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000880) };
static  ANTLR3_BITSET_LIST FOLLOW_vector_in_newparmvector597	= { FOLLOW_vector_in_newparmvector597_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_one_digit_string_in_newparmvector601  */
static	ANTLR3_BITWORD FOLLOW_one_digit_string_in_newparmvector601_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_one_digit_string_in_newparmvector601	= { FOLLOW_one_digit_string_in_newparmvector601_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_CLOSE_BR_in_newparmvector613  */
static	ANTLR3_BITWORD FOLLOW_T_CLOSE_BR_in_newparmvector613_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_T_CLOSE_BR_in_newparmvector613	= { FOLLOW_T_CLOSE_BR_in_newparmvector613_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_CLOSE_BR_in_newparmvector615  */
static	ANTLR3_BITWORD FOLLOW_T_CLOSE_BR_in_newparmvector615_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_T_CLOSE_BR_in_newparmvector615	= { FOLLOW_T_CLOSE_BR_in_newparmvector615_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_expr696  */
static	ANTLR3_BITWORD FOLLOW_term_in_expr696_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_expr696	= { FOLLOW_term_in_expr696_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_OR_in_expr718  */
static	ANTLR3_BITWORD FOLLOW_T_OR_in_expr718_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010500) };
static  ANTLR3_BITSET_LIST FOLLOW_T_OR_in_expr718	= { FOLLOW_T_OR_in_expr718_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_expr722  */
static	ANTLR3_BITWORD FOLLOW_term_in_expr722_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_expr722	= { FOLLOW_term_in_expr722_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_expr754  */
static	ANTLR3_BITWORD FOLLOW_term_in_expr754_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_expr754	= { FOLLOW_term_in_expr754_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_NOT_in_factor786  */
static	ANTLR3_BITWORD FOLLOW_T_NOT_in_factor786_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010500) };
static  ANTLR3_BITSET_LIST FOLLOW_T_NOT_in_factor786	= { FOLLOW_T_NOT_in_factor786_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nest_factor_in_factor790  */
static	ANTLR3_BITWORD FOLLOW_nest_factor_in_factor790_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_nest_factor_in_factor790	= { FOLLOW_nest_factor_in_factor790_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nest_factor_in_factor809  */
static	ANTLR3_BITWORD FOLLOW_nest_factor_in_factor809_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_nest_factor_in_factor809	= { FOLLOW_nest_factor_in_factor809_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_OPEN_BR_in_nest_factor857  */
static	ANTLR3_BITWORD FOLLOW_T_OPEN_BR_in_nest_factor857_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010500) };
static  ANTLR3_BITSET_LIST FOLLOW_T_OPEN_BR_in_nest_factor857	= { FOLLOW_T_OPEN_BR_in_nest_factor857_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_nest_factor861  */
static	ANTLR3_BITWORD FOLLOW_expr_in_nest_factor861_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_nest_factor861	= { FOLLOW_expr_in_nest_factor861_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_CLOSE_BR_in_nest_factor864  */
static	ANTLR3_BITWORD FOLLOW_T_CLOSE_BR_in_nest_factor864_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_T_CLOSE_BR_in_nest_factor864	= { FOLLOW_T_CLOSE_BR_in_nest_factor864_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_vector_in_nest_factor887  */
static	ANTLR3_BITWORD FOLLOW_vector_in_nest_factor887_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_vector_in_nest_factor887	= { FOLLOW_vector_in_nest_factor887_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_factor_in_term970  */
static	ANTLR3_BITWORD FOLLOW_factor_in_term970_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_factor_in_term970	= { FOLLOW_factor_in_term970_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_AND_in_term994  */
static	ANTLR3_BITWORD FOLLOW_T_AND_in_term994_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010500) };
static  ANTLR3_BITSET_LIST FOLLOW_T_AND_in_term994	= { FOLLOW_T_AND_in_term994_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_factor_in_term998  */
static	ANTLR3_BITWORD FOLLOW_factor_in_term998_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020002) };
static  ANTLR3_BITSET_LIST FOLLOW_factor_in_term998	= { FOLLOW_factor_in_term998_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_factor_in_term1032  */
static	ANTLR3_BITWORD FOLLOW_factor_in_term1032_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_factor_in_term1032	= { FOLLOW_factor_in_term1032_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_synpred1_Simple696  */
static	ANTLR3_BITWORD FOLLOW_term_in_synpred1_Simple696_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_synpred1_Simple696	= { FOLLOW_term_in_synpred1_Simple696_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_OR_in_synpred1_Simple718  */
static	ANTLR3_BITWORD FOLLOW_T_OR_in_synpred1_Simple718_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010500) };
static  ANTLR3_BITSET_LIST FOLLOW_T_OR_in_synpred1_Simple718	= { FOLLOW_T_OR_in_synpred1_Simple718_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_synpred1_Simple722  */
static	ANTLR3_BITWORD FOLLOW_term_in_synpred1_Simple722_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_synpred1_Simple722	= { FOLLOW_term_in_synpred1_Simple722_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_factor_in_synpred2_Simple970  */
static	ANTLR3_BITWORD FOLLOW_factor_in_synpred2_Simple970_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_factor_in_synpred2_Simple970	= { FOLLOW_factor_in_synpred2_Simple970_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_AND_in_synpred2_Simple994  */
static	ANTLR3_BITWORD FOLLOW_T_AND_in_synpred2_Simple994_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010500) };
static  ANTLR3_BITSET_LIST FOLLOW_T_AND_in_synpred2_Simple994	= { FOLLOW_T_AND_in_synpred2_Simple994_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_factor_in_synpred2_Simple998  */
static	ANTLR3_BITWORD FOLLOW_factor_in_synpred2_Simple998_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020002) };
static  ANTLR3_BITSET_LIST FOLLOW_factor_in_synpred2_Simple998	= { FOLLOW_factor_in_synpred2_Simple998_bits, 1	};
     

 
 
/* ==============================================
 * Parsing rules
 */
/** 
 * $ANTLR start complex_cond
 * C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:36:1: complex_cond returns [ComplexCondition* c] : expr[0] ;
 */
static ComplexCondition*
complex_cond(pSimpleParser ctx)
{   
    ComplexCondition* c = NULL;

    /* Initialize rule variables
     */

    ctx->pSimpleParser_complex_condTop = pSimpleParser_complex_condPush(ctx);
     	(SCOPE_TOP(complex_cond))->flag=0;	(SCOPE_TOP(complex_cond))->cc=0;

    {
        // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:43:3: ( expr[0] )
        // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:43:5: expr[0]
        {
            FOLLOWPUSH(FOLLOW_expr_in_complex_cond80);
            expr(ctx, 0);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecomplex_condEx;
            }
            if (HASFAILED())
            {
                pSimpleParser_complex_condPop(ctx);

                return c;
            }
            if ( BACKTRACKING==0 ) 
            {
                c=	(SCOPE_TOP(complex_cond))->cc;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecomplex_condEx; /* Prevent compiler warnings */
    rulecomplex_condEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }

    pSimpleParser_complex_condPop(ctx);

    return c;
}
/* $ANTLR end complex_cond */

/** 
 * $ANTLR start solution
 * C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:46:1: solution returns [ExtendedQuast* res] : quast_group[0] ;
 */
static ExtendedQuast*
solution(pSimpleParser ctx)
{   
    ExtendedQuast* res = NULL;

    /* Initialize rule variables
     */

    ctx->pSimpleParser_solutionTop = pSimpleParser_solutionPush(ctx);
    {
        // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:52:5: ( quast_group[0] )
        // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:52:7: quast_group[0]
        {
            FOLLOWPUSH(FOLLOW_quast_group_in_solution109);
            quast_group(ctx, 0);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesolutionEx;
            }
            if (HASFAILED())
            {
                pSimpleParser_solutionPop(ctx);

                return res;
            }
            if ( BACKTRACKING==0 ) 
            {
                res=	(SCOPE_TOP(solution))->sol;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesolutionEx; /* Prevent compiler warnings */
    rulesolutionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }

    pSimpleParser_solutionPop(ctx);

    return res;
}
/* $ANTLR end solution */

/** 
 * $ANTLR start all_vectors
 * C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:57:1: all_vectors returns [std::list <std::list <int>* >* res] : ( vector )+ ;
 */
static std::list <std::list <int>* >*
all_vectors(pSimpleParser ctx)
{   
    std::list <std::list <int>* >* res = NULL;

    std::list<int> * vector1;
    #undef	RETURN_TYPE_vector1
    #define	RETURN_TYPE_vector1 std::list<int> *

    /* Initialize rule variables
     */


    res=new std::list <std::list <int>* >;
    vector1 = NULL;

    {
        // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:60:3: ( ( vector )+ )
        // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:60:6: ( vector )+
        {
            // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:60:6: ( vector )+
            {
                int cnt1=0;

                for (;;)
                {
                    int alt1=2;
            	switch ( LA(1) ) 
            	{
            	case T_VEC_beg:
            		{
            			alt1=1;
            		}
            	    break;

            	}

            	switch (alt1) 
            	{
            	    case 1:
            	        // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:60:7: vector
            	        {
            	            FOLLOWPUSH(FOLLOW_vector_in_all_vectors144);
            	            vector1=vector(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleall_vectorsEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return res;
            	            }
            	            if ( BACKTRACKING==0 ) 
            	            {
            	                res->push_back(vector1);
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt1 >= 1 )
            		{
            		    goto loop1;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return res;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleall_vectorsEx;
            	}
            	cnt1++;
                }
                loop1: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleall_vectorsEx; /* Prevent compiler warnings */
    ruleall_vectorsEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return res;
}
/* $ANTLR end all_vectors */

/** 
 * $ANTLR start digits_line
 * C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:63:1: digits_line returns [std::list <int>* res] : ( one_digit_string )+ ;
 */
static std::list <int>*
digits_line(pSimpleParser ctx)
{   
    std::list <int>* res = NULL;

    int* one_digit_string2;
    #undef	RETURN_TYPE_one_digit_string2
    #define	RETURN_TYPE_one_digit_string2 int*

    /* Initialize rule variables
     */


    res=new std::list <int>;
    one_digit_string2 = NULL;

    {
        // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:67:3: ( ( one_digit_string )+ )
        // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:67:4: ( one_digit_string )+
        {
            // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:67:4: ( one_digit_string )+
            {
                int cnt2=0;

                for (;;)
                {
                    int alt2=2;
            	switch ( LA(1) ) 
            	{
            	case T_DIGIT_STRING:
            		{
            			alt2=1;
            		}
            	    break;

            	}

            	switch (alt2) 
            	{
            	    case 1:
            	        // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:67:5: one_digit_string
            	        {
            	            FOLLOWPUSH(FOLLOW_one_digit_string_in_digits_line175);
            	            one_digit_string2=one_digit_string(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruledigits_lineEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return res;
            	            }
            	            if ( BACKTRACKING==0 ) 
            	            {
            	                int *rab=one_digit_string2; res->push_back(*rab); delete rab;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt2 >= 1 )
            		{
            		    goto loop2;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return res;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruledigits_lineEx;
            	}
            	cnt2++;
                }
                loop2: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledigits_lineEx; /* Prevent compiler warnings */
    ruledigits_lineEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return res;
}
/* $ANTLR end digits_line */

/** 
 * $ANTLR start vector
 * C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:69:1: vector returns [std::list<int> * res] : T_VEC_beg digits_line T_VEC_end ;
 */
static std::list<int> *
vector(pSimpleParser ctx)
{   
    std::list<int> * res = NULL;

    std::list <int>* digits_line3;
    #undef	RETURN_TYPE_digits_line3
    #define	RETURN_TYPE_digits_line3 std::list <int>*

    /* Initialize rule variables
     */


    digits_line3 = NULL;

    {
        // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:71:3: ( T_VEC_beg digits_line T_VEC_end )
        // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:71:4: T_VEC_beg digits_line T_VEC_end
        {
             MATCHT(T_VEC_beg, &FOLLOW_T_VEC_beg_in_vector194); 
            if  (HASEXCEPTION())
            {
                goto rulevectorEx;
            }
            if (HASFAILED())
            {
                return res;
            }
            FOLLOWPUSH(FOLLOW_digits_line_in_vector196);
            digits_line3=digits_line(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevectorEx;
            }
            if (HASFAILED())
            {
                return res;
            }
             MATCHT(T_VEC_end, &FOLLOW_T_VEC_end_in_vector198); 
            if  (HASEXCEPTION())
            {
                goto rulevectorEx;
            }
            if (HASFAILED())
            {
                return res;
            }
            if ( BACKTRACKING==0 ) 
            {
                res=digits_line3;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulevectorEx; /* Prevent compiler warnings */
    rulevectorEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return res;
}
/* $ANTLR end vector */

/** 
 * $ANTLR start one_digit_string
 * C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:74:1: one_digit_string returns [int* res] : T_DIGIT_STRING ;
 */
static int*
one_digit_string(pSimpleParser ctx)
{   
    int* res = NULL;

    pANTLR3_COMMON_TOKEN    T_DIGIT_STRING4;

    /* Initialize rule variables
     */


    res=new int;
    T_DIGIT_STRING4       = NULL;

    {
        // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:77:3: ( T_DIGIT_STRING )
        // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:77:6: T_DIGIT_STRING
        {
            T_DIGIT_STRING4 = (pANTLR3_COMMON_TOKEN) MATCHT(T_DIGIT_STRING, &FOLLOW_T_DIGIT_STRING_in_one_digit_string226); 
            if  (HASEXCEPTION())
            {
                goto ruleone_digit_stringEx;
            }
            if (HASFAILED())
            {
                return res;
            }
            if ( BACKTRACKING==0 ) 
            {
                *res = getTokenInteger(T_DIGIT_STRING4);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleone_digit_stringEx; /* Prevent compiler warnings */
    ruleone_digit_stringEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return res;
}
/* $ANTLR end one_digit_string */

/** 
 * $ANTLR start end_of_lines
 * C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:80:1: end_of_lines : T_EOF ;
 */
static void
end_of_lines(pSimpleParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:81:4: ( T_EOF )
        // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:81:6: T_EOF
        {
             MATCHT(T_EOF, &FOLLOW_T_EOF_in_end_of_lines242); 
            if  (HASEXCEPTION())
            {
                goto ruleend_of_linesEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleend_of_linesEx; /* Prevent compiler warnings */
    ruleend_of_linesEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end end_of_lines */

/** 
 * $ANTLR start quast_group
 * C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:88:1: quast_group[ExtendedQuast* cur] : ( quast[ncur] | ng= newparm_group quast[ncur] );
 */
static void
quast_group(pSimpleParser ctx, ExtendedQuast* cur)
{   
    NewParamVector* ng;
    #undef	RETURN_TYPE_ng
    #define	RETURN_TYPE_ng NewParamVector*

    /* Initialize rule variables
     */


    ExtendedQuast* ncur;
    ng = NULL;

    {
        {
            //  C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:91:9: ( quast[ncur] | ng= newparm_group quast[ncur] )
            
            ANTLR3_UINT32 alt3;

            alt3=2;

            switch ( LA(1) ) 
            {
            case T_OPEN_BR:
            	{
            		switch ( LA(2) ) 
            		{
            		case T_CLOSE_BR:
            		case T_IF:
            		case T_LIST:
            			{
            				alt3=1;
            			}
            		    break;
            		case T_NEWPARAM:
            			{
            				alt3=2;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return ;
            		    }
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 3;
            		    EXCEPTION->state        = 1;


            		    goto rulequast_groupEx;
            		}

            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 3;
                EXCEPTION->state        = 0;


                goto rulequast_groupEx;
            }

            switch (alt3) 
            {
        	case 1:
        	    // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:92:5: quast[ncur]
        	    {
        	        if ( BACKTRACKING==0 ) 
        	        {

        	               	std::cout<<"quast group"<<std::endl;
        	               	if (cur==0)
        	               	{
        	               	 //ncur= new ExtendedQuast(in_dim,out_dim);
        	               	 ncur= new ExtendedQuast(0,0);
        	               	 	(SCOPE_TOP(solution))->sol=ncur;
        	               	 }
        	               	 else
        	               	 ncur=cur;
        	               	 
        	        }
        	        FOLLOWPUSH(FOLLOW_quast_in_quast_group297);
        	        quast(ctx, ncur);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulequast_groupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:106:5: ng= newparm_group quast[ncur]
        	    {
        	        FOLLOWPUSH(FOLLOW_newparm_group_in_quast_group312);
        	        ng=newparm_group(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulequast_groupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	               	if (cur==0)
        	               	{
        	               	 //ncur= new ExtendedQuast(in_dim,out_dim);
        	               	 ncur= new ExtendedQuast(0,0);
        	               	 	(SCOPE_TOP(solution))->sol=ncur;
        	               	 }
        	               	 else
        	               	 ncur=cur;
        	                    ncur->setNewParamVector(ng);	 
        	               	 
        	               	 
        	        }
        	        FOLLOWPUSH(FOLLOW_quast_in_quast_group330);
        	        quast(ctx, ncur);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulequast_groupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulequast_groupEx; /* Prevent compiler warnings */
    rulequast_groupEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end quast_group */

/** 
 * $ANTLR start quast
 * C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:124:1: quast[ExtendedQuast* cur] : ( form[ncur] | T_OPEN_BR T_IF cc= complex_cond quast_group[truebr] quast_group[falsebr] T_CLOSE_BR );
 */
static void
quast(pSimpleParser ctx, ExtendedQuast* cur)
{   
    ComplexCondition* cc;
    #undef	RETURN_TYPE_cc
    #define	RETURN_TYPE_cc ComplexCondition*

    /* Initialize rule variables
     */



    ExtendedQuast* truebr;
    ExtendedQuast* falsebr;
    ExtendedQuast* ncur;

    cc = NULL;

    {
        {
            //  C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:131:4: ( form[ncur] | T_OPEN_BR T_IF cc= complex_cond quast_group[truebr] quast_group[falsebr] T_CLOSE_BR )
            
            ANTLR3_UINT32 alt4;

            alt4=2;

            switch ( LA(1) ) 
            {
            case T_OPEN_BR:
            	{
            		switch ( LA(2) ) 
            		{
            		case T_CLOSE_BR:
            		case T_LIST:
            			{
            				alt4=1;
            			}
            		    break;
            		case T_IF:
            			{
            				alt4=2;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return ;
            		    }
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 4;
            		    EXCEPTION->state        = 1;


            		    goto rulequastEx;
            		}

            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 4;
                EXCEPTION->state        = 0;


                goto rulequastEx;
            }

            switch (alt4) 
            {
        	case 1:
        	    // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:132:4: form[ncur]
        	    {
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            ncur=cur;
        	        }
        	        FOLLOWPUSH(FOLLOW_form_in_quast365);
        	        form(ctx, ncur);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulequastEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:136:4: T_OPEN_BR T_IF cc= complex_cond quast_group[truebr] quast_group[falsebr] T_CLOSE_BR
        	    {
        	         MATCHT(T_OPEN_BR, &FOLLOW_T_OPEN_BR_in_quast380); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulequastEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	         MATCHT(T_IF, &FOLLOW_T_IF_in_quast382); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulequastEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        FOLLOWPUSH(FOLLOW_complex_cond_in_quast386);
        	        cc=complex_cond(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulequastEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	              	ncur=cur;
        	              	ncur->setCondition(cc);
        	              	ncur->setTypeOfNod(ExtendedQuast::INNER);
        	              	truebr= new ExtendedQuast(0,0);
        	              	falsebr= new ExtendedQuast(0,0);
        	              	ncur->setTrueBranch(truebr);
        	              	ncur->setFalseBranch(falsebr);
        	              	
        	              	
        	        }
        	        FOLLOWPUSH(FOLLOW_quast_group_in_quast397);
        	        quast_group(ctx, truebr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulequastEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        FOLLOWPUSH(FOLLOW_quast_group_in_quast400);
        	        quast_group(ctx, falsebr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulequastEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	         MATCHT(T_CLOSE_BR, &FOLLOW_T_CLOSE_BR_in_quast403); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulequastEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulequastEx; /* Prevent compiler warnings */
    rulequastEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end quast */

/** 
 * $ANTLR start form
 * C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:151:1: form[ExtendedQuast* cur] : ( T_OPEN_BR T_LIST (v= vector )+ T_CLOSE_BR | T_OPEN_BR T_CLOSE_BR );
 */
static void
form(pSimpleParser ctx, ExtendedQuast* cur)
{   
    std::list<int> * v;
    #undef	RETURN_TYPE_v
    #define	RETURN_TYPE_v std::list<int> *

    /* Initialize rule variables
     */



    ParamPoint* reval;
    SimpleLinearExpression* sle;
    int k=0;

    v = NULL;

    {
        {
            //  C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:158:3: ( T_OPEN_BR T_LIST (v= vector )+ T_CLOSE_BR | T_OPEN_BR T_CLOSE_BR )
            
            ANTLR3_UINT32 alt6;

            alt6=2;

            switch ( LA(1) ) 
            {
            case T_OPEN_BR:
            	{
            		switch ( LA(2) ) 
            		{
            		case T_LIST:
            			{
            				alt6=1;
            			}
            		    break;
            		case T_CLOSE_BR:
            			{
            				alt6=2;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return ;
            		    }
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 6;
            		    EXCEPTION->state        = 1;


            		    goto ruleformEx;
            		}

            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 6;
                EXCEPTION->state        = 0;


                goto ruleformEx;
            }

            switch (alt6) 
            {
        	case 1:
        	    // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:160:3: T_OPEN_BR T_LIST (v= vector )+ T_CLOSE_BR
        	    {
        	         MATCHT(T_OPEN_BR, &FOLLOW_T_OPEN_BR_in_form431); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleformEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	         MATCHT(T_LIST, &FOLLOW_T_LIST_in_form433); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleformEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	             	reval= new ParamPoint(10);
        	             	
        	             	
        	        }
        	        // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:166:4: (v= vector )+
        	        {
        	            int cnt5=0;

        	            for (;;)
        	            {
        	                int alt5=2;
        	        	switch ( LA(1) ) 
        	        	{
        	        	case T_VEC_beg:
        	        		{
        	        			alt5=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt5) 
        	        	{
        	        	    case 1:
        	        	        // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:166:5: v= vector
        	        	        {
        	        	            FOLLOWPUSH(FOLLOW_vector_in_form448);
        	        	            v=vector(ctx);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleformEx;
        	        	            }
        	        	            if (HASFAILED())
        	        	            {
        	        	                return ;
        	        	            }
        	        	            if ( BACKTRACKING==0 ) 
        	        	            {

        	        	                 	int vsize=v->size();
        	        	                 	int * a=new int[vsize];
        	        	                 	std::list<int>::iterator it=v->begin();
        	        	                 	int i=0;
        	        	                 	do
        	        	                 	{
        	        	                 	
        	        	                 	
        	        	                 	a[i]=*it;
        	        	                 	it++;
        	        	                 	i++;
        	        	                 	}
        	        	                 	while(i<vsize);
        	        	                 	
        	        	                 	 sle =new SimpleLinearExpression(a,vsize);
        	        	                 	 (*reval)[k]=sle;
        	        	                 	 k++;
        	        	                 	 
        	        	            }

        	        	        }
        	        	        break;

        	        	    default:
        	        	    
        	        		if ( cnt5 >= 1 )
        	        		{
        	        		    goto loop5;
        	        		}
        	        		if (BACKTRACKING>0)
        	        		{
        	        		    FAILEDFLAG = ANTLR3_TRUE;
        	        		    return ;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto ruleformEx;
        	        	}
        	        	cnt5++;
        	            }
        	            loop5: ;	/* Jump to here if this rule does not match */
        	        }
        	         MATCHT(T_CLOSE_BR, &FOLLOW_T_CLOSE_BR_in_form465); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleformEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            cur->setLinExpr(reval);
        	             	 cur->setTypeOfNod(ExtendedQuast::LEAF);
        	             	 
        	        }

        	    }
        	    break;
        	case 2:
        	    // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:194:3: T_OPEN_BR T_CLOSE_BR
        	    {
        	         MATCHT(T_OPEN_BR, &FOLLOW_T_OPEN_BR_in_form485); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleformEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	         MATCHT(T_CLOSE_BR, &FOLLOW_T_CLOSE_BR_in_form487); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleformEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleformEx; /* Prevent compiler warnings */
    ruleformEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end form */

/** 
 * $ANTLR start newparm_group
 * C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:198:1: newparm_group returns [NewParamVector* npv] : (n= newparmvector )+ ;
 */
static NewParamVector*
newparm_group(pSimpleParser ctx)
{   
    NewParamVector* npv = NULL;

    NewParamEquation* n;
    #undef	RETURN_TYPE_n
    #define	RETURN_TYPE_n NewParamEquation*

    /* Initialize rule variables
     */



    NewParamVector* npvec;

    n = NULL;

    {
        // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:203:3: ( (n= newparmvector )+ )
        // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:204:3: (n= newparmvector )+
        {
            if ( BACKTRACKING==0 ) 
            {

                 	npvec= new NewParamVector();
                 	
            }
            // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:207:3: (n= newparmvector )+
            {
                int cnt7=0;

                for (;;)
                {
                    int alt7=2;
            	switch ( LA(1) ) 
            	{
            	case T_OPEN_BR:
            		{
            			switch ( LA(2) ) 
            			{
            			case T_NEWPARAM:
            				{
            					alt7=1;
            				}
            			    break;

            			}

            		}
            	    break;

            	}

            	switch (alt7) 
            	{
            	    case 1:
            	        // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:208:3: n= newparmvector
            	        {
            	            FOLLOWPUSH(FOLLOW_newparmvector_in_newparm_group528);
            	            n=newparmvector(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulenewparm_groupEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return npv;
            	            }
            	            if ( BACKTRACKING==0 ) 
            	            {

            	                 	npvec->PushBack(n);
            	                 	
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt7 >= 1 )
            		{
            		    goto loop7;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return npv;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulenewparm_groupEx;
            	}
            	cnt7++;
                }
                loop7: ;	/* Jump to here if this rule does not match */
            }
            if ( BACKTRACKING==0 ) 
            {
                npv=npvec;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulenewparm_groupEx; /* Prevent compiler warnings */
    rulenewparm_groupEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return npv;
}
/* $ANTLR end newparm_group */

/** 
 * $ANTLR start newparmvector
 * C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:217:1: newparmvector returns [NewParamEquation* npe] : T_OPEN_BR T_NEWPARAM ( one_digit_string )? T_OPEN_BR T_DIV v= vector ch= one_digit_string T_CLOSE_BR T_CLOSE_BR ;
 */
static NewParamEquation*
newparmvector(pSimpleParser ctx)
{   
    NewParamEquation* npe = NULL;

    std::list<int> * v;
    #undef	RETURN_TYPE_v
    #define	RETURN_TYPE_v std::list<int> *

    int* ch;
    #undef	RETURN_TYPE_ch
    #define	RETURN_TYPE_ch int*

    /* Initialize rule variables
     */



    NewParamEquation* npeq;

    v = NULL;
    ch = NULL;

    {
        // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:223:4: ( T_OPEN_BR T_NEWPARAM ( one_digit_string )? T_OPEN_BR T_DIV v= vector ch= one_digit_string T_CLOSE_BR T_CLOSE_BR )
        // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:224:4: T_OPEN_BR T_NEWPARAM ( one_digit_string )? T_OPEN_BR T_DIV v= vector ch= one_digit_string T_CLOSE_BR T_CLOSE_BR
        {
             MATCHT(T_OPEN_BR, &FOLLOW_T_OPEN_BR_in_newparmvector576); 
            if  (HASEXCEPTION())
            {
                goto rulenewparmvectorEx;
            }
            if (HASFAILED())
            {
                return npe;
            }
             MATCHT(T_NEWPARAM, &FOLLOW_T_NEWPARAM_in_newparmvector578); 
            if  (HASEXCEPTION())
            {
                goto rulenewparmvectorEx;
            }
            if (HASFAILED())
            {
                return npe;
            }

            // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:224:25: ( one_digit_string )?
            {
                int alt8=2;
                switch ( LA(1) ) 
                {
                    case T_DIGIT_STRING:
                    	{
                    		alt8=1;
                    	}
                        break;
                }

                switch (alt8) 
                {
            	case 1:
            	    // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:224:25: one_digit_string
            	    {
            	        FOLLOWPUSH(FOLLOW_one_digit_string_in_newparmvector580);
            	        one_digit_string(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenewparmvectorEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return npe;
            	        }

            	    }
            	    break;

                }
            }
             MATCHT(T_OPEN_BR, &FOLLOW_T_OPEN_BR_in_newparmvector583); 
            if  (HASEXCEPTION())
            {
                goto rulenewparmvectorEx;
            }
            if (HASFAILED())
            {
                return npe;
            }
             MATCHT(T_DIV, &FOLLOW_T_DIV_in_newparmvector585); 
            if  (HASEXCEPTION())
            {
                goto rulenewparmvectorEx;
            }
            if (HASFAILED())
            {
                return npe;
            }
            FOLLOWPUSH(FOLLOW_vector_in_newparmvector597);
            v=vector(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenewparmvectorEx;
            }
            if (HASFAILED())
            {
                return npe;
            }
            FOLLOWPUSH(FOLLOW_one_digit_string_in_newparmvector601);
            ch=one_digit_string(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenewparmvectorEx;
            }
            if (HASFAILED())
            {
                return npe;
            }
            if ( BACKTRACKING==0 ) 
            {

                  	int vsize=v->size();
                 	int * a=new int[vsize];
                 	std::list<int>::iterator it=v->begin();
                 	int i=0;
                 	do
                 	{
                 	
                 	
                 	a[i]=*it;
                 	it++;
                 	i++;
                 	}
                 	while(i<vsize);
                 	
                 	npeq= new NewParamEquation();
                 	npeq->m_dim=vsize;
                 	npeq->m_denom=*(ch);
                 	npeq->m_coefs=a;
                 	
                 	npe=npeq;
                  	  
                  	 
            }
             MATCHT(T_CLOSE_BR, &FOLLOW_T_CLOSE_BR_in_newparmvector613); 
            if  (HASEXCEPTION())
            {
                goto rulenewparmvectorEx;
            }
            if (HASFAILED())
            {
                return npe;
            }
             MATCHT(T_CLOSE_BR, &FOLLOW_T_CLOSE_BR_in_newparmvector615); 
            if  (HASEXCEPTION())
            {
                goto rulenewparmvectorEx;
            }
            if (HASFAILED())
            {
                return npe;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulenewparmvectorEx; /* Prevent compiler warnings */
    rulenewparmvectorEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return npe;
}
/* $ANTLR end newparmvector */

/** 
 * $ANTLR start expr
 * C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:260:1: expr[ComplexCondition* cur] returns [ComplexCondition* truecur] options {backtrack=true; } : (childlf= term[$expr::left] ( T_OR childrt= term[$expr::right] )+ | child= term[$expr::ecur] );
 */
static ComplexCondition*
expr(pSimpleParser ctx, ComplexCondition* cur)
{   
    ComplexCondition* truecur = NULL;

    ComplexCondition* childlf;
    #undef	RETURN_TYPE_childlf
    #define	RETURN_TYPE_childlf ComplexCondition*

    ComplexCondition* childrt;
    #undef	RETURN_TYPE_childrt
    #define	RETURN_TYPE_childrt ComplexCondition*

    ComplexCondition* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child ComplexCondition*

    /* Initialize rule variables
     */

    ctx->pSimpleParser_exprTop = pSimpleParser_exprPush(ctx);

    	(SCOPE_TOP(expr))->leaflist=new std::list<ComplexCondition*>(0);
    	(SCOPE_TOP(expr))->ecur=cur;
    	(SCOPE_TOP(expr))->it1=new std::list<ComplexCondition*>::iterator();
    	(SCOPE_TOP(expr))->it2=new std::list<ComplexCondition*>::iterator();
    	(SCOPE_TOP(expr))->k=1;
    	(SCOPE_TOP(expr))->flag=false;
    	(SCOPE_TOP(expr))->right=0;

    childlf = NULL;
    childrt = NULL;
    child = NULL;

    {
        {
            //  C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:295:3: (childlf= term[$expr::left] ( T_OR childrt= term[$expr::right] )+ | child= term[$expr::ecur] )
            
            ANTLR3_UINT32 alt10;

            alt10=2;

            switch ( LA(1) ) 
            {
            case T_NOT:
            	{

            		{
            		    int LA10_1 = LA(2);
            		    if ( (synpred1_Simple(ctx)) ) 
            		    {
            		        alt10=1;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt10=2;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            pSimpleParser_exprPop(ctx);

            		            return truecur;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 10;
            		        EXCEPTION->state        = 1;


            		        goto ruleexprEx;
            		    }
            		}
            	}
                break;
            case T_OPEN_BR:
            	{

            		{
            		    int LA10_2 = LA(2);
            		    if ( (synpred1_Simple(ctx)) ) 
            		    {
            		        alt10=1;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt10=2;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            pSimpleParser_exprPop(ctx);

            		            return truecur;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 10;
            		        EXCEPTION->state        = 2;


            		        goto ruleexprEx;
            		    }
            		}
            	}
                break;
            case T_VEC_beg:
            	{

            		{
            		    int LA10_3 = LA(2);
            		    if ( (synpred1_Simple(ctx)) ) 
            		    {
            		        alt10=1;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt10=2;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            pSimpleParser_exprPop(ctx);

            		            return truecur;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 10;
            		        EXCEPTION->state        = 3;


            		        goto ruleexprEx;
            		    }
            		}
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pSimpleParser_exprPop(ctx);

                    return truecur;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 10;
                EXCEPTION->state        = 0;


                goto ruleexprEx;
            }

            switch (alt10) 
            {
        	case 1:
        	    // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:299:3: childlf= term[$expr::left] ( T_OR childrt= term[$expr::right] )+
        	    {
        	        if ( BACKTRACKING==0 ) 
        	        {

        	             		(SCOPE_TOP(expr))->left= new ComplexCondition();
        	             	
        	             	
        	        }
        	        FOLLOWPUSH(FOLLOW_term_in_expr696);
        	        childlf=term(ctx, 	(SCOPE_TOP(expr))->left);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            pSimpleParser_exprPop(ctx);

        	            return truecur;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            	(SCOPE_TOP(expr))->left=childlf;
        	        }
        	        // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:305:3: ( T_OR childrt= term[$expr::right] )+
        	        {
        	            int cnt9=0;

        	            for (;;)
        	            {
        	                int alt9=2;
        	        	switch ( LA(1) ) 
        	        	{
        	        	case T_OR:
        	        		{
        	        			alt9=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt9) 
        	        	{
        	        	    case 1:
        	        	        // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:306:3: T_OR childrt= term[$expr::right]
        	        	        {
        	        	            if ( BACKTRACKING==0 ) 
        	        	            {

        	        	                 	
        	        	                 	std::cout<<"expr enter"<<std::endl;
        	        	                 		(SCOPE_TOP(expr))->leaflist->push_front(new ComplexCondition());
        	        	                 	*	(SCOPE_TOP(expr))->it1=	(SCOPE_TOP(expr))->leaflist->begin();
        	        	                 		(SCOPE_TOP(expr))->right=**(	(SCOPE_TOP(expr))->it1); 
        	        	                 	
        	        	            }
        	        	             MATCHT(T_OR, &FOLLOW_T_OR_in_expr718); 
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleexprEx;
        	        	            }
        	        	            if (HASFAILED())
        	        	            {
        	        	                pSimpleParser_exprPop(ctx);

        	        	                return truecur;
        	        	            }
        	        	            FOLLOWPUSH(FOLLOW_term_in_expr722);
        	        	            childrt=term(ctx, 	(SCOPE_TOP(expr))->right);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleexprEx;
        	        	            }
        	        	            if (HASFAILED())
        	        	            {
        	        	                pSimpleParser_exprPop(ctx);

        	        	                return truecur;
        	        	            }
        	        	            if ( BACKTRACKING==0 ) 
        	        	            {

        	        	                 		(SCOPE_TOP(expr))->leaflist->push_front(childrt);
        	        	                 	*	(SCOPE_TOP(expr))->it1=	(SCOPE_TOP(expr))->leaflist->begin();
        	        	                 	std::cout<<"expr enter"<<std::endl;
        	        	                 	if ((	(SCOPE_TOP(expr))->ecur==0)&&(	(SCOPE_TOP(expr))->flag==false))
        	        	                 	{
        	        	                 	   std::cout<<'1'<<std::endl;
        	        	                 	   	(SCOPE_TOP(expr))->root=new ComplexCondition(ComplexCondition::OR,	(SCOPE_TOP(expr))->left,**	(SCOPE_TOP(expr))->it1);
        	        	                 	   /* if (	(SCOPE_TOP(complex_cond))->flag=false)
        	        	                 	   	(SCOPE_TOP(complex_cond))->cc=	(SCOPE_TOP(expr))->root;
        	        	                 	   */
        	        	                 	   	(SCOPE_TOP(expr))->flag=true;
        	        	                 	}
        	        	                 	else
        	        	                 	  if (	(SCOPE_TOP(expr))->flag==true)
        	        	                 	  {
        	        	                 	     	std::cout<<'2'<<std::endl;
        	        	                 	    
        	        	                 	    	(SCOPE_TOP(expr))->leaflist->push_front(new ComplexCondition(ComplexCondition::OR,	(SCOPE_TOP(expr))->left,**	(SCOPE_TOP(expr))->it1));
        	        	                            	(SCOPE_TOP(expr))->root=*(	(SCOPE_TOP(expr))->leaflist->begin());
        	        	                          
        	        	                           
        	        	                            
        	        	                          
        	        	                 	   
        	        	                 	 
        	        	                 	   }
        	        	                 	   else 
        	        	                 	   if ((	(SCOPE_TOP(expr))->ecur!=0)&&(	(SCOPE_TOP(expr))->flag==false))
        	        	                 	   {
        	        	                 	   std::cout<<'3'<<std::endl;
        	        	                 	   	(SCOPE_TOP(expr))->root=	(SCOPE_TOP(expr))->ecur;
        	        	                 	   	(SCOPE_TOP(expr))->root->setOperation(ComplexCondition::OR);
        	        	                 	   	(SCOPE_TOP(expr))->root->setLeft(	(SCOPE_TOP(expr))->left);
        	        	                 	   	(SCOPE_TOP(expr))->root->setRight(**	(SCOPE_TOP(expr))->it1);
        	        	                 	   	(SCOPE_TOP(expr))->flag=true;
        	        	                 	   }
        	        	                 	 if (	(SCOPE_TOP(complex_cond))->flag==0)
        	        	                 	   	(SCOPE_TOP(complex_cond))->cc=	(SCOPE_TOP(expr))->root;
        	        	                 	   
        	        	                 	std::cout<<'4'<<std::endl;
        	        	                 		(SCOPE_TOP(expr))->left->setFather(	(SCOPE_TOP(expr))->root);
        	        	                 	(**	(SCOPE_TOP(expr))->it1)->setFather(	(SCOPE_TOP(expr))->root);
        	        	                 		(SCOPE_TOP(expr))->root->setOperation(ComplexCondition::OR);
        	        	                 		(SCOPE_TOP(expr))->left=	(SCOPE_TOP(expr))->root;
        	        	                 	/*	(SCOPE_TOP(expr))->right=**(	(SCOPE_TOP(expr))->it1);*/ 	
        	        	                       	truecur=	(SCOPE_TOP(expr))->root;
        	        	                       	
        	        	            }

        	        	        }
        	        	        break;

        	        	    default:
        	        	    
        	        		if ( cnt9 >= 1 )
        	        		{
        	        		    goto loop9;
        	        		}
        	        		if (BACKTRACKING>0)
        	        		{
        	        		    FAILEDFLAG = ANTLR3_TRUE;
        	        		    pSimpleParser_exprPop(ctx);

        	        		    return truecur;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto ruleexprEx;
        	        	}
        	        	cnt9++;
        	            }
        	            loop9: ;	/* Jump to here if this rule does not match */
        	        }

        	    }
        	    break;
        	case 2:
        	    // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:367:3: child= term[$expr::ecur]
        	    {
        	        FOLLOWPUSH(FOLLOW_term_in_expr754);
        	        child=term(ctx, 	(SCOPE_TOP(expr))->ecur);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            pSimpleParser_exprPop(ctx);

        	            return truecur;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            truecur=child;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleexprEx; /* Prevent compiler warnings */
    ruleexprEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                    if (	(SCOPE_TOP(expr))->leaflist!=0)
                      delete 	(SCOPE_TOP(expr))->leaflist;
                    if (	(SCOPE_TOP(expr))->it1!=0)
                      delete 	(SCOPE_TOP(expr))->it1;
                    if (	(SCOPE_TOP(expr))->it2!=0)
                      delete 	(SCOPE_TOP(expr))->it2;

                }
            }

    pSimpleParser_exprPop(ctx);

    return truecur;
}
/* $ANTLR end expr */

/** 
 * $ANTLR start factor
 * C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:370:1: factor[ComplexCondition* cur] returns [ComplexCondition* truecur] : ( T_NOT childlt= nest_factor[left] | childrt= nest_factor[cur] );
 */
static ComplexCondition*
factor(pSimpleParser ctx, ComplexCondition* cur)
{   
    ComplexCondition* truecur = NULL;

    ComplexCondition* childlt;
    #undef	RETURN_TYPE_childlt
    #define	RETURN_TYPE_childlt ComplexCondition*

    ComplexCondition* childrt;
    #undef	RETURN_TYPE_childrt
    #define	RETURN_TYPE_childrt ComplexCondition*

    /* Initialize rule variables
     */



    ComplexCondition* left=0;
    ComplexCondition* root=0;

    childlt = NULL;
    childrt = NULL;

    {
        {
            //  C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:376:3: ( T_NOT childlt= nest_factor[left] | childrt= nest_factor[cur] )
            
            ANTLR3_UINT32 alt11;

            alt11=2;

            switch ( LA(1) ) 
            {
            case T_NOT:
            	{
            		alt11=1;
            	}
                break;
            case T_VEC_beg:
            case T_OPEN_BR:
            	{
            		alt11=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return truecur;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 11;
                EXCEPTION->state        = 0;


                goto rulefactorEx;
            }

            switch (alt11) 
            {
        	case 1:
        	    // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:377:3: T_NOT childlt= nest_factor[left]
        	    {
        	        if ( BACKTRACKING==0 ) 
        	        {

        	             	left= new ComplexCondition();
        	             	std::cout<<"not1"<<std::endl;
        	             	
        	        }
        	         MATCHT(T_NOT, &FOLLOW_T_NOT_in_factor786); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefactorEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return truecur;
        	        }
        	        FOLLOWPUSH(FOLLOW_nest_factor_in_factor790);
        	        childlt=nest_factor(ctx, left);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefactorEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return truecur;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	             	std::cout<<"not2"<<std::endl;
        	             	left=childlt;
        	             	if (cur==0) 
        	             	{
        	             	   
        	             	   root =new ComplexCondition(ComplexCondition::NOT,left);
        	             	   if (	(SCOPE_TOP(complex_cond))->flag==0)
        	             	   	(SCOPE_TOP(complex_cond))->cc=root;
        	             	}
        	             	else
        	             	  {root=cur;
        	             	   root->setOperation(ComplexCondition::NOT);
        	             	   root->setLeft(left);
        	             	   }
        	             	std::cout<<"factor"<<std::endl;
        	             	 	left->setFather(root);  
        	             	
        	             	truecur=root;
        	             	   
        	             	
        	             	
        	        }

        	    }
        	    break;
        	case 2:
        	    // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:406:5: childrt= nest_factor[cur]
        	    {
        	        FOLLOWPUSH(FOLLOW_nest_factor_in_factor809);
        	        childrt=nest_factor(ctx, cur);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefactorEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return truecur;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            truecur=childrt;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulefactorEx; /* Prevent compiler warnings */
    rulefactorEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return truecur;
}
/* $ANTLR end factor */

/** 
 * $ANTLR start nest_factor
 * C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:409:1: nest_factor[ComplexCondition* cur] returns [ComplexCondition* truecur] : ( T_OPEN_BR child= expr[cur] T_CLOSE_BR | vector );
 */
static ComplexCondition*
nest_factor(pSimpleParser ctx, ComplexCondition* cur)
{   
    ComplexCondition* truecur = NULL;

    ComplexCondition* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child ComplexCondition*

    std::list<int> * vector5;
    #undef	RETURN_TYPE_vector5
    #define	RETURN_TYPE_vector5 std::list<int> *

    /* Initialize rule variables
     */



    ComplexCondition* root;


    child = NULL;
    vector5 = NULL;

    {
        {
            //  C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:415:9: ( T_OPEN_BR child= expr[cur] T_CLOSE_BR | vector )
            
            ANTLR3_UINT32 alt12;

            alt12=2;

            switch ( LA(1) ) 
            {
            case T_OPEN_BR:
            	{
            		alt12=1;
            	}
                break;
            case T_VEC_beg:
            	{
            		alt12=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return truecur;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 12;
                EXCEPTION->state        = 0;


                goto rulenest_factorEx;
            }

            switch (alt12) 
            {
        	case 1:
        	    // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:416:8: T_OPEN_BR child= expr[cur] T_CLOSE_BR
        	    {
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            	(SCOPE_TOP(complex_cond))->flag++;
        	        }
        	         MATCHT(T_OPEN_BR, &FOLLOW_T_OPEN_BR_in_nest_factor857); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenest_factorEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return truecur;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_nest_factor861);
        	        child=expr(ctx, cur);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenest_factorEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return truecur;
        	        }
        	         MATCHT(T_CLOSE_BR, &FOLLOW_T_CLOSE_BR_in_nest_factor864); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenest_factorEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return truecur;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            	(SCOPE_TOP(complex_cond))->flag--;truecur=child;
        	        }

        	    }
        	    break;
        	case 2:
        	    // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:418:9: vector
        	    {
        	        FOLLOWPUSH(FOLLOW_vector_in_nest_factor887);
        	        vector5=vector(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenest_factorEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return truecur;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	             	
        	             	int * a=new int[vector5->size()];
        	             	std::list<int>::iterator it=vector5->begin();
        	             	for (int i=0;i<vector5->size();i++)
        	             	{
        	             	
        	             	std::advance(it,i); 
        	             	a[i]=*it;
        	             	std::cout<<*it<<std::endl;
        	             	it=vector5->begin();
        	             	
        	             	}
        	             	LatticeGraph::Inequality* in= new LatticeGraph::Inequality(a,vector5->size());
        	             	
        	             	if (cur==0) 
        	             	{
        	             	   root =new LatticeGraph::ComplexCondition(in);
        	             	    if (	(SCOPE_TOP(complex_cond))->flag==0)
        	             	   	(SCOPE_TOP(complex_cond))->cc=root;
        	             	   
        	             	}
        	             	else
        	             	{  
        	             	  /*
        	             	  root=cur;
        	             	  ComplexCondition* nod=new ComplexCondition(in) ;
        	             	  ComplexCondition* buf=root->getFather();
        	             	  std::cout<<"in"<<std::endl;
        	             	  if (buf->getLeft()==root){
        	             	      std::cout<<"out1"<<std::endl;
        	             	      delete buf->getLeft();
        	             	      buf->setLeft(nod);
        	             	      buf->getLeft()->setFather(buf);
        	             	  }
        	             	  else
        	             	  {
        	             	   std::cout<<"out2"<<std::endl;
        	             	  delete buf->getRight();
        	             	      buf->setRight(nod);
        	             	      buf->getRight()->setFather(buf);
        	             	  }
        	             	  */
        	             	root=cur;
        	             	root->setInequality(in);
        	             	root->setOperation(ComplexCondition::COMPARE);
        	             	}
        	             	truecur=cur;
        	             	
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulenest_factorEx; /* Prevent compiler warnings */
    rulenest_factorEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return truecur;
}
/* $ANTLR end nest_factor */

/** 
 * $ANTLR start term
 * C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:474:2: term[ComplexCondition* cur] returns [ComplexCondition* truecur] options {backtrack=true; } : (childlf= factor[$term::left] ( T_AND childrt= factor[$term::right] )+ | child= factor[$term::ecur] );
 */
static ComplexCondition*
term(pSimpleParser ctx, ComplexCondition* cur)
{   
    ComplexCondition* truecur = NULL;

    ComplexCondition* childlf;
    #undef	RETURN_TYPE_childlf
    #define	RETURN_TYPE_childlf ComplexCondition*

    ComplexCondition* childrt;
    #undef	RETURN_TYPE_childrt
    #define	RETURN_TYPE_childrt ComplexCondition*

    ComplexCondition* child;
    #undef	RETURN_TYPE_child
    #define	RETURN_TYPE_child ComplexCondition*

    /* Initialize rule variables
     */

    ctx->pSimpleParser_termTop = pSimpleParser_termPush(ctx);

    	(SCOPE_TOP(term))->leaflist=new std::list<ComplexCondition*>(0);
    	(SCOPE_TOP(term))->it1=new std::list<ComplexCondition*>::iterator();
    	(SCOPE_TOP(term))->it2=new std::list<ComplexCondition*>::iterator();
    	(SCOPE_TOP(term))->ecur=cur;
    	(SCOPE_TOP(term))->k=1;
    	(SCOPE_TOP(term))->flag=false;
    	(SCOPE_TOP(term))->right=0;
    	(SCOPE_TOP(term))->flag2=false;

    childlf = NULL;
    childrt = NULL;
    child = NULL;

    {
        {
            //  C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:510:3: (childlf= factor[$term::left] ( T_AND childrt= factor[$term::right] )+ | child= factor[$term::ecur] )
            
            ANTLR3_UINT32 alt14;

            alt14=2;

            switch ( LA(1) ) 
            {
            case T_NOT:
            	{

            		{
            		    int LA14_1 = LA(2);
            		    if ( (synpred2_Simple(ctx)) ) 
            		    {
            		        alt14=1;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt14=2;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            pSimpleParser_termPop(ctx);

            		            return truecur;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 14;
            		        EXCEPTION->state        = 1;


            		        goto ruletermEx;
            		    }
            		}
            	}
                break;
            case T_OPEN_BR:
            	{

            		{
            		    int LA14_2 = LA(2);
            		    if ( (synpred2_Simple(ctx)) ) 
            		    {
            		        alt14=1;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt14=2;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            pSimpleParser_termPop(ctx);

            		            return truecur;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 14;
            		        EXCEPTION->state        = 2;


            		        goto ruletermEx;
            		    }
            		}
            	}
                break;
            case T_VEC_beg:
            	{

            		{
            		    int LA14_3 = LA(2);
            		    if ( (synpred2_Simple(ctx)) ) 
            		    {
            		        alt14=1;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt14=2;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            pSimpleParser_termPop(ctx);

            		            return truecur;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 14;
            		        EXCEPTION->state        = 3;


            		        goto ruletermEx;
            		    }
            		}
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pSimpleParser_termPop(ctx);

                    return truecur;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 14;
                EXCEPTION->state        = 0;


                goto ruletermEx;
            }

            switch (alt14) 
            {
        	case 1:
        	    // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:514:3: childlf= factor[$term::left] ( T_AND childrt= factor[$term::right] )+
        	    {
        	        if ( BACKTRACKING==0 ) 
        	        {

        	             		(SCOPE_TOP(term))->left= new ComplexCondition();
        	             	
        	             	
        	        }
        	        FOLLOWPUSH(FOLLOW_factor_in_term970);
        	        childlf=factor(ctx, 	(SCOPE_TOP(term))->left);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            pSimpleParser_termPop(ctx);

        	            return truecur;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            	(SCOPE_TOP(term))->left=childlf;
        	        }
        	        // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:521:3: ( T_AND childrt= factor[$term::right] )+
        	        {
        	            int cnt13=0;

        	            for (;;)
        	            {
        	                int alt13=2;
        	        	switch ( LA(1) ) 
        	        	{
        	        	case T_AND:
        	        		{
        	        			alt13=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt13) 
        	        	{
        	        	    case 1:
        	        	        // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:522:3: T_AND childrt= factor[$term::right]
        	        	        {
        	        	            if ( BACKTRACKING==0 ) 
        	        	            {

        	        	                 	bool fl=false;
        	        	                 	std::cout<<"term enter"<<std::endl;
        	        	                 		(SCOPE_TOP(term))->leaflist->push_front(new ComplexCondition());
        	        	                 	*	(SCOPE_TOP(term))->it1=	(SCOPE_TOP(term))->leaflist->begin();
        	        	                 		(SCOPE_TOP(term))->right=*(*	(SCOPE_TOP(term))->it1); 
        	        	                 	
        	        	                 	
        	        	                 	
        	        	            }
        	        	             MATCHT(T_AND, &FOLLOW_T_AND_in_term994); 
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruletermEx;
        	        	            }
        	        	            if (HASFAILED())
        	        	            {
        	        	                pSimpleParser_termPop(ctx);

        	        	                return truecur;
        	        	            }
        	        	            FOLLOWPUSH(FOLLOW_factor_in_term998);
        	        	            childrt=factor(ctx, 	(SCOPE_TOP(term))->right);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruletermEx;
        	        	            }
        	        	            if (HASFAILED())
        	        	            {
        	        	                pSimpleParser_termPop(ctx);

        	        	                return truecur;
        	        	            }
        	        	            if ( BACKTRACKING==0 ) 
        	        	            {

        	        	                 		(SCOPE_TOP(term))->leaflist->push_front(childrt);
        	        	                 	*	(SCOPE_TOP(term))->it1=	(SCOPE_TOP(term))->leaflist->begin();
        	        	                 	std::cout<<"term enter"<<std::endl;
        	        	                 	if ((	(SCOPE_TOP(term))->ecur==0)&&(	(SCOPE_TOP(term))->flag==false)) 
        	        	                 	{
        	        	                 	    std::cout<<"t 1"<<std::endl;
        	        	                 	   	(SCOPE_TOP(term))->root=new ComplexCondition(ComplexCondition::AND,	(SCOPE_TOP(term))->left,**	(SCOPE_TOP(term))->it1);
        	        	                 	    if (	(SCOPE_TOP(complex_cond))->flag==0)
        	        	                 	    {
        	        	                 	   	(SCOPE_TOP(complex_cond))->cc=	(SCOPE_TOP(term))->root;
        	        	                 	  	(SCOPE_TOP(term))->flag2=true;
        	        	                 	   }
        	        	                 	   	(SCOPE_TOP(term))->flag=true;
        	        	                 	}
        	        	                 	else
        	        	                 	  if (	(SCOPE_TOP(term))->flag==true)
        	        	                 	  {
        	        	                 	     	 std::cout<<"t 2"<<std::endl;
        	        	                 	     	
        	        	                 	    
        	        	                 	    
        	        	                 	    	(SCOPE_TOP(term))->leaflist->push_front(new ComplexCondition(ComplexCondition::AND,	(SCOPE_TOP(term))->left,**	(SCOPE_TOP(term))->it1));
        	        	                            	(SCOPE_TOP(term))->root=*(	(SCOPE_TOP(term))->leaflist->begin());
        	        	                           
        	        	                           
        	        	                            /*
        	        	                            	(SCOPE_TOP(term))->leaflist->push_front(new ComplexCondition( ComplexCondition::AND,**	(SCOPE_TOP(term))->it1,	(SCOPE_TOP(term))->left));  	
        	        	                 	     	(SCOPE_TOP(term))->root=*(	(SCOPE_TOP(term))->leaflist->begin());
        	        	                 	    	(SCOPE_TOP(term))->k=1;
        	        	                 	 */
        	        	                 	 
        	        	                 	   }
        	        	                 	   else 
        	        	                 	   if ((	(SCOPE_TOP(term))->ecur!=0)&&(	(SCOPE_TOP(term))->flag==false))
        	        	                 	   {
        	        	                 	    std::cout<<"t 3"<<std::endl;
        	        	                 	   	(SCOPE_TOP(term))->root=	(SCOPE_TOP(term))->ecur;
        	        	                 	   	(SCOPE_TOP(term))->root->setOperation(ComplexCondition::AND);
        	        	                 	   	(SCOPE_TOP(term))->root->setLeft(	(SCOPE_TOP(term))->left);
        	        	                 	   	(SCOPE_TOP(term))->root->setRight(**	(SCOPE_TOP(term))->it1);
        	        	                 	   	(SCOPE_TOP(term))->flag=true;
        	        	                 	   }
        	        	                 	  if ((	(SCOPE_TOP(complex_cond))->flag==0)&&(	(SCOPE_TOP(term))->flag2==true))
        	        	                 	    	   	(SCOPE_TOP(complex_cond))->cc=	(SCOPE_TOP(term))->root;
        	        	                 	   
        	        	                 	 std::cout<<"t 4"<<std::endl;
        	        	                 		(SCOPE_TOP(term))->left->setFather(	(SCOPE_TOP(term))->root);
        	        	                 	(**	(SCOPE_TOP(term))->it1)->setFather(	(SCOPE_TOP(term))->root);
        	        	                 	/*	(SCOPE_TOP(term))->root->setOperation(ComplexCondition::AND);*/
        	        	                 		(SCOPE_TOP(term))->left=	(SCOPE_TOP(term))->root;
        	        	                 	std::cout<<"t 4"<<std::endl;
        	        	                 	/*	(SCOPE_TOP(term))->right=*(*	(SCOPE_TOP(term))->it1); */
        	        	                 	std::cout<<"t 4"<<std::endl; 	
        	        	                       	truecur=	(SCOPE_TOP(term))->root;
        	        	                       	
        	        	            }

        	        	        }
        	        	        break;

        	        	    default:
        	        	    
        	        		if ( cnt13 >= 1 )
        	        		{
        	        		    goto loop13;
        	        		}
        	        		if (BACKTRACKING>0)
        	        		{
        	        		    FAILEDFLAG = ANTLR3_TRUE;
        	        		    pSimpleParser_termPop(ctx);

        	        		    return truecur;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto ruletermEx;
        	        	}
        	        	cnt13++;
        	            }
        	            loop13: ;	/* Jump to here if this rule does not match */
        	        }

        	    }
        	    break;
        	case 2:
        	    // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:593:4: child= factor[$term::ecur]
        	    {
        	        FOLLOWPUSH(FOLLOW_factor_in_term1032);
        	        child=factor(ctx, 	(SCOPE_TOP(term))->ecur);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            pSimpleParser_termPop(ctx);

        	            return truecur;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            truecur=child;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruletermEx; /* Prevent compiler warnings */
    ruletermEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                    if (	(SCOPE_TOP(term))->leaflist!=0)
                      delete 	(SCOPE_TOP(term))->leaflist;
                    if (	(SCOPE_TOP(term))->it1!=0)
                      delete 	(SCOPE_TOP(term))->it1;
                    if (	(SCOPE_TOP(term))->it2!=0)
                      delete 	(SCOPE_TOP(term))->it2;

                }
            }

    pSimpleParser_termPop(ctx);

    return truecur;
}
/* $ANTLR end term */

// $ANTLR start synpred1_Simple
static void synpred1_Simple_fragment(pSimpleParser ctx ) 
{
	ComplexCondition* childlf;
	#undef	RETURN_TYPE_childlf
	#define	RETURN_TYPE_childlf ComplexCondition*

	ComplexCondition* childrt;
	#undef	RETURN_TYPE_childrt
	#define	RETURN_TYPE_childrt ComplexCondition*

	childlf = NULL;
	childrt = NULL;

    // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:299:3: (childlf= term[$expr::left] ( T_OR childrt= term[$expr::right] )+ )
    // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:299:3: childlf= term[$expr::left] ( T_OR childrt= term[$expr::right] )+
    {
        if ( BACKTRACKING==0 ) 
        {

             		(SCOPE_TOP(expr))->left= new ComplexCondition();
             	
             	
        }
        FOLLOWPUSH(FOLLOW_term_in_synpred1_Simple696);
        childlf=term(ctx, 	(SCOPE_TOP(expr))->left);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_SimpleEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:305:3: ( T_OR childrt= term[$expr::right] )+
        {
            int cnt15=0;

            for (;;)
            {
                int alt15=2;
        	switch ( LA(1) ) 
        	{
        	case T_OR:
        		{
        			alt15=1;
        		}
        	    break;

        	}

        	switch (alt15) 
        	{
        	    case 1:
        	        // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:306:3: T_OR childrt= term[$expr::right]
        	        {
        	            if ( BACKTRACKING==0 ) 
        	            {

        	                 	
        	                 	std::cout<<"expr enter"<<std::endl;
        	                 		(SCOPE_TOP(expr))->leaflist->push_front(new ComplexCondition());
        	                 	*	(SCOPE_TOP(expr))->it1=	(SCOPE_TOP(expr))->leaflist->begin();
        	                 		(SCOPE_TOP(expr))->right=**(	(SCOPE_TOP(expr))->it1); 
        	                 	
        	            }
        	             MATCHT(T_OR, &FOLLOW_T_OR_in_synpred1_Simple718); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulesynpred1_SimpleEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }
        	            FOLLOWPUSH(FOLLOW_term_in_synpred1_Simple722);
        	            childrt=term(ctx, 	(SCOPE_TOP(expr))->right);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulesynpred1_SimpleEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }
        	        break;

        	    default:
        	    
        		if ( cnt15 >= 1 )
        		{
        		    goto loop15;
        		}
        		if (BACKTRACKING>0)
        		{
        		    FAILEDFLAG = ANTLR3_TRUE;
        		    return ;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto rulesynpred1_SimpleEx;
        	}
        	cnt15++;
            }
            loop15: ;	/* Jump to here if this rule does not match */
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred1_SimpleEx; /* Prevent compiler warnings */
rulesynpred1_SimpleEx: ;

}
// $ANTLR end synpred1_Simple

// $ANTLR start synpred2_Simple
static void synpred2_Simple_fragment(pSimpleParser ctx ) 
{
	ComplexCondition* childlf;
	#undef	RETURN_TYPE_childlf
	#define	RETURN_TYPE_childlf ComplexCondition*

	ComplexCondition* childrt;
	#undef	RETURN_TYPE_childrt
	#define	RETURN_TYPE_childrt ComplexCondition*

	childlf = NULL;
	childrt = NULL;

    // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:514:3: (childlf= factor[$term::left] ( T_AND childrt= factor[$term::right] )+ )
    // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:514:3: childlf= factor[$term::left] ( T_AND childrt= factor[$term::right] )+
    {
        if ( BACKTRACKING==0 ) 
        {

             		(SCOPE_TOP(term))->left= new ComplexCondition();
             	
             	
        }
        FOLLOWPUSH(FOLLOW_factor_in_synpred2_Simple970);
        childlf=factor(ctx, 	(SCOPE_TOP(term))->left);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred2_SimpleEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:521:3: ( T_AND childrt= factor[$term::right] )+
        {
            int cnt16=0;

            for (;;)
            {
                int alt16=2;
        	switch ( LA(1) ) 
        	{
        	case T_AND:
        		{
        			alt16=1;
        		}
        	    break;

        	}

        	switch (alt16) 
        	{
        	    case 1:
        	        // C:\\Documents and Settings\\Sergey\\Рабочий стол\\Simple.g:522:3: T_AND childrt= factor[$term::right]
        	        {
        	            if ( BACKTRACKING==0 ) 
        	            {

        	                 	bool fl=false;
        	                 	std::cout<<"term enter"<<std::endl;
        	                 		(SCOPE_TOP(term))->leaflist->push_front(new ComplexCondition());
        	                 	*	(SCOPE_TOP(term))->it1=	(SCOPE_TOP(term))->leaflist->begin();
        	                 		(SCOPE_TOP(term))->right=*(*	(SCOPE_TOP(term))->it1); 
        	                 	
        	                 	
        	                 	
        	            }
        	             MATCHT(T_AND, &FOLLOW_T_AND_in_synpred2_Simple994); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulesynpred2_SimpleEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }
        	            FOLLOWPUSH(FOLLOW_factor_in_synpred2_Simple998);
        	            childrt=factor(ctx, 	(SCOPE_TOP(term))->right);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulesynpred2_SimpleEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }
        	        break;

        	    default:
        	    
        		if ( cnt16 >= 1 )
        		{
        		    goto loop16;
        		}
        		if (BACKTRACKING>0)
        		{
        		    FAILEDFLAG = ANTLR3_TRUE;
        		    return ;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto rulesynpred2_SimpleEx;
        	}
        	cnt16++;
            }
            loop16: ;	/* Jump to here if this rule does not match */
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred2_SimpleEx; /* Prevent compiler warnings */
rulesynpred2_SimpleEx: ;

}
// $ANTLR end synpred2_Simple
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
static ANTLR3_BOOLEAN synpred2_Simple(pSimpleParser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred2_Simple_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred1_Simple(pSimpleParser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred1_Simple_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}

/* End of syntactic predicates
 * ==============================================
 */

 
 



/* End of code
 * =============================================================================
 */
